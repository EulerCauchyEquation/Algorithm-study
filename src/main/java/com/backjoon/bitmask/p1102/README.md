# 백준 1102번 문제

* 날짜 : 20.04.10
* 언어 : java
* IDE : IntelliJ IDEA community 

## 요구사항

<img src="/doc/backjoon/bitmask/p1102/requirement.png"> 

## 풀이

생각보다 까다로운 문제 유형이었다. 아무래도 비트 마스크 문제는 자주 접하는 유형이 아니라서 그랬던 것이 아닌가하는 생각이 든다.  일단 위 문제는 Dynamic을 생각해볼 수 있다. 이유는 DFS하는 과정을 보면 중복이 나타난다.

과정
```
1. 고장나지 않은 발전소들 중 고장난 발전소를 선택한다.
2. 1번을 반복한다.
3. 가동 중인 발전소의 수가 P가 될 때 스탑.
```

문제는 memoization을 어떻게 할 것인가였다.  가동중인 발전소와 고장난 발전소의 상태를 저장해야하는데 이것이 매우 까다롭다.  저장하려면 엄청난 메모리량이 필요하다.  이때 bitmask를 이용하여 그 상태를 유용하게 저장한다.  마치 네트워크 패키지의 flag처럼 이용하는 것이다.   

예를 들어 <br>
1101이면,  2번은 고장난 상태이고 1,3,4는 가동 중인 상태다. <br>
0101이면,  1, 3번은 가동 중인 상태고, 2, 4번은 고장난 상태다. 

이렇게 상태를 이진수로 상태를 저장하는 방법이다. 

점화식.
```
dfs(state) = Min(
        dfs(state | 1 << 고장난 a 발전기 위치)  + costs[현재][a]
        dfs(state | 1 << 고장난 b 발전기 위치)  + costs[현재][b]
        ...
        dfs(state | 1 << 고장난 z 발전기 위치)  + costs[현재][z]
)
```

 단, 이 방법은 발전소의 수가  1 < n < 16 이기 때문에 가능한 방법이다.  만일 그 숫자가 더 커지면 사용할 수 없다.  이때는 아마 다른 방법을 또 연구해봐야할 것이다.

 
 