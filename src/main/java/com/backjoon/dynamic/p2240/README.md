# 백준 2240번 문제

* 날짜 : 20.03.20
* 언어 : java
* IDE : IntelliJ IDEA community 

## 요구사항

<img src="/doc/backjoon2240.png"> 

## 풀이

경우의 수를 따지면서 들어가야 하므로, 당연히 전수조사를 생각하니 DFS문제다.  그래서 먼저 어떤 자식노드들로 탐색할 지 case를 따져봤다.

---
case 1. 힘이 남아있는 경우<br>
1.1  다른 위치로 이동 함<br>
1.2  현 위치 고수<br>
case 2. 이동할 힘이 없음<br>
2.1 현 위치 고수
---

이렇게 case를 생각했다.  결국 case는 모두 3가지이다.  그런데 이때,  현 위치를 고수하는 경우는 힘이 남아 있든 없든 고수를 하기 때문에 다시 2가지로 축소했다.

---
case 1. 힘이 남아있는데, 이동 함 <br>
case 2. 현 위치 고수
---

이렇게 자식 노드들을 가지고 DFS를 돌린다. <br>
노드를 방문하면
---
1. 먼저 현재 나무 위치가 이 time때 나무 위치와 맞는지 확인하여 hit를 저장해둔다.
2. 부모 노드로부터 넘어온 hit값을 더한다.
3. 자식 노드들을 방문하며, hit값을 넘긴다. 
---

이렇게 시나리오를 작성해서 DFS를 돌렸다. 하지만, 지수 시간 복잡도를 해결할 수 없었다.  그래서 DP나, Greedy를 생각했지만 응용할 수가 없었다.  그러다, 생각을 살짝 바꿔보았다.  시나리오 중에 노드 방문 시 자식 노드들 중 가장 큰 hit값을 저장하는 것이다.  그러면 memoization이 가능하니, DP가 가능하다.

---
1. 먼저 현재 나무 위치가 이 time때 나무 위치와 맞는지 확인하여 hit를 저장해둔다.
2. 자식 노드들을 방문하며, case들 중 가장 큰 hit를 확보한다.
3. 확보한 값과 hit를 더한다.  
---

<img src="/doc/backjoon2240/picture1.jpg"> 

쉽게 생각하기가 어려웠다.  살짝 발상의 전환이 필요한 문제였다.  시간 복잡도는 O(WT)가 나온다.