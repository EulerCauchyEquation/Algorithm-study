# 프로그래머스 : 서울에서 경산까지

* 날짜 : 20.03.26
* 언어 : java
* IDE : IntelliJ IDEA community 

## 요구사항

<img src="/doc/programmers/dynamic/p7/requirement.png"> 

## 풀이

DFS에서 출발한다.  조건을 분석해보면

case.

---
case 1. 도보로 이동    (단, 시간이 가능하다면) <br>
case 2. 자전거로 이동   (단, 시간이 가능하다면)

---

조건을 분석해보면 이렇게 2가지 경우의 수를 갖는다. 이를 DFS로 풀이하면 지수 시간 복잡도를 갖는다.   
다음 예로 그림으로 분석해본다.  

예. 
```
int[][] travel = {
        {40, 200, 30, 100},
        {80, 300, 70, 150},
        {50, 400, 30, 300}};
int k = 140;
```

<img src="/doc/programmers/dynamic/p7/picture1.jpg"> 

이를 좀더 개선하기 위해 이리저리 해보다 점화식을 도출할 수 있었고,  중복이 보여서 dp로 해결할 수 있었다.

점화식.
```
1) 시간이 충분한 경우
dfs(n, 남은시간) = Max (
dfs(n + 1,  남은시간 - 도보시간(n) ) + 도보(n), 
dfs(n + 1,  남은시간 - 자전거시간(n)) + 자전거(n) )  


2) 도보 시간만 충분한 경우
dfs(n, 남은시간) = dfs(n + 1,  남은시간 - 도보시간(n) ) + 도보(n)

3) 자전거 이동 시간만 충분한 경우
dfs(n, 남은시간) = dfs(n + 1,  남은시간 - 자전거시간(n)) + 자전거(n)

4) 두 경우다 시간 불충분
dfs(n, 남은시간) = 0  
```